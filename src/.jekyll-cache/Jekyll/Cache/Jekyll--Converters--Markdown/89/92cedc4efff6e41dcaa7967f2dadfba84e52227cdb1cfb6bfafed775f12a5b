I"-o<h1 id="intro">Intro</h1>
<p>How are containers made? Usually, from a series of statements like <code class="language-plaintext highlighter-rouge">RUN</code>, <code class="language-plaintext highlighter-rouge">FROM</code>, and <code class="language-plaintext highlighter-rouge">COPY</code>, which are put into a Dockerfile and built.  But how are those commands turned into a container image and then a running container?  We can build up an intuition for how this works by understanding the phases involved and creating a container image ourselves. We will create an image programmatically and then develop a trivial syntactic frontend and use it to build an image.</p>

<h3 id="game-plan">Game Plan:</h3>
<ul>
  <li>☑️ Intro</li>
  <li>☐️ Background</li>
  <li>☐ Understanding Compiler Stages and BuildKit</li>
  <li>☐ Programmatically Creating an Image</li>
  <li>☐ Building a Frontend for BuildKit</li>
</ul>

<h2 id="on-docker-build">On <code class="language-plaintext highlighter-rouge">Docker Build</code></h2>

<p>We can create container images in several ways. We can use Buildpacks, we can use build tools like Bazel or sbt, but by far, the most common way images are built is using <code class="language-plaintext highlighter-rouge">docker build</code> with a Dockerfile.  The familiar base images Alpine, Ubuntu, and Debian are all created this way.</p>

<p>Here is an example Dockerfile:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM alpine
COPY README.md README.md
RUN echo "standard docker build" &gt; /built.txt"
</code></pre></div></div>
<p>We will be using variations on this Dockerfile throughout this tutorial.</p>

<p>We can build it like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build . -t test
</code></pre></div></div>

<p>But what is happening when you call <code class="language-plaintext highlighter-rouge">docker build</code>? To understand that, we will need a little background.</p>

<h1 id="background">Background</h1>
<p>A docker image is made up of layers. Those layers form an immutable filesystem.  A container image also has some descriptive data, such as the start-up command, the ports to expose, and volumes to mount. When you <code class="language-plaintext highlighter-rouge">docker run</code> an image, it starts up inside a container runtime.</p>

<p>I like to think about images and containers by analogy. If an image is like an executable, then a container is like a process. You can run multiple containers from one image, and a running image isn’t an image at all but a container.</p>

<p><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FCorecursive%2F9JSrPv-1IN.png?alt=media&amp;token=765f193c-516b-4aac-bd09-33cdd3640a23" alt="An image is like an executable" /></p>

<p>Continuing our analogy, <a href="https://github.com/moby/buildkit">BuildKit</a> is a compiler, just like <a href="https://en.wikipedia.org/wiki/LLVM">LLVM</a>.  But whereas a compiler takes source code and libraries and produces an executable, BuildKit takes a Dockerfile and a file path and creates a container image.</p>

<p><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FCorecursive%2FjSHQUTrFTH.png?alt=media&amp;token=d53f4ede-e735-46a9-aca0-2854a4866738" alt="BuildKit is like a compiler for Docker images" /></p>

<p>Docker build uses BuildKit, to turn a Dockerfile into a docker image, OCI image, or another image format.  In this walk-through, we will primarily use BuildKit directly.</p>

<p><img src="./bk-internals-images/buildctl.png" alt="Docker Daemon with BuildKit Daemon inside it" /></p>

<p>This <a href="https://blog.earthly.dev/what-is-buildkit-and-what-can-i-do-with-it/">primer on using buildkit</a> supplies some helpful background on using BuildKit, <code class="language-plaintext highlighter-rouge">buildkitd</code>, and <code class="language-plaintext highlighter-rouge">buildctl</code> via the command-line. However, the only prerequisite for today is running <code class="language-plaintext highlighter-rouge">brew install buildkit</code> or the appropriate OS <a href="https://github.com/moby/buildkit#quick-start">equivalent</a> steps.</p>

<h2 id="how-do-compilers-work">How Do Compilers Work?</h2>
<p>A traditional compiler takes code in a high-level language and lowers it to a lower-level language.  In most conventional ahead-of-time compilers, the final target is machine code. Machine code is a low-level programming language that your CPU understands<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup>.</p>

<table>
  <thead>
    <tr>
      <th>ℹ️ Fun Fact: Machine Code VS. Assembly</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Machine code is written in binary. This makes it hard for a human to understand.  Assembly code is a plain-text representation of machine code that is designed to be somewhat human-readable. There is generally a 1-1 mapping between instructions the machine understands (in machine code) and the OpCodes in Assembly</td>
    </tr>
  </tbody>
</table>

<p>Compiling the classic c “Hello, World” into x86 assembly code using the CLANG frontend for LLVM looks like this:</p>

<p><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FCorecursive%2FL6uGpUhnhF.png?alt=media&amp;token=098db6b7-7b7f-414c-b863-972f311e150d" alt="Compiling Hello World to X86 assembly" /></p>

<p>Creating an image from a dockerfile works a similar way:</p>

<p><img src="bk-internals-images/build-an-image.png" alt="Compiling Docker Image" /></p>

<p>BuildKit is passed the Dockerfile and the build context, which is the present working directory in the above diagram. In simplified terms, each line in the dockerfile is turned into a layer in the resulting image.  One significant way image building differs from compiling is this build context.  A compiler’s input is limited to source code, whereas <code class="language-plaintext highlighter-rouge">docker build</code> takes a reference to the host filesystem as an input and uses it to perform actions such as <code class="language-plaintext highlighter-rouge">COPY</code>.</p>

<h2 id="there-is-a-catch">There Is a Catch</h2>
<p>The earlier diagram of compiling “Hello, World” in a single step missed a vital detail. Computer hardware is not a singular thing. If every compiler were a hand-coded mapping from a high-level language to x86 machine code, then moving to the Apple M1 processor would be quite challenging because it has a different instruction set.</p>

<p>Compiler authors have overcome this challenge by splitting compilation into phases.  The traditional phases are the frontend, the backend, and the middle. The middle phase is sometimes called the optimizer, and it deals primarily with an internal representation (IR).</p>

<p><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FCorecursive%2FKM0Xdj_7ge.png?alt=media&amp;token=a6452203-b0fb-4ed2-9ab4-5d522ef3504d" alt="Three stage build process" /></p>

<p>This staged approach means you don’t need a new compiler for each new machine architecture.  Instead, you just need a new backend. Here is an example of what that looks like in <a href="https://llvm.org/">LLVM</a>:</p>

<p><img src="bk-internals-images/backends.png" alt="Backends of LLVM" /></p>

<h2 id="intermediate-representations">Intermediate Representations</h2>
<p>This multiple backend approach allows LLVM to target ARM, X86, and many other machine architectures using LLVM Intermediate Representation (IR) as a standard protocol.  LLVM IR is a human-readable programming language that backends need to be able to take as input. To create a new backend, you need to write a translator from LLVM IR to your target machine code. That translation is the primary job of each backend.</p>

<p>Once you have this IR, you have a protocol that various phases of the compiler can use as an interface, and you can build not just many backends but many frontends as well. LLVM has frontends for numerous languages, including C++, Julia, Objective-C, Rust, and Swift.</p>

<p><img src="bk-internals-images/frontends.png" alt="One compiler, with many frontend and backends" /></p>

<p>If you can write a translation from your language to LLVM IR, LLVM can translate that IR into machine code for all the backends it supports. This translation function is the primary job of a compiler frontend.</p>

<p>In practice, there is much more to it than that. Frontends need to tokenize and parse input files, and they need to return pleasant errors. Backends often have target-specific optimizations to perform and heuristics to apply. But for this tutorial, the critical point is that having a standard representation ends up being a bridge that connects many front ends with many backends. This shared interface removes the need to create a compiler for every combination of language and machine architecture. It is a simple but very empowering trick!</p>

<h2 id="buidkit">BuidKit</h2>
<p>Images, unlike executables, have their own isolated filesystem. Nevertheless, the task of building an image looks very similar to compiling an executable. They can have varying syntax (dockerfile1.0, dockerfile1.2), and the result must target several machine architectures (arm64 vs. x86_64).</p>

<blockquote>
  <p>“LLB is to Dockerfile what LLVM IR is to C” - <a href="https://github.com/moby/buildkit/blob/master/README.md">BuildKit Readme</a></p>
</blockquote>

<p>This similarity was not lost on the BuildKit creators.  BuildKit has its own intermediate representation, LLB.  And where LLVM IR has things like function calls and garbage-collection strategies, LLB has mounting filesystems and executing statements.</p>

<p><img src="bk-internals-images/LLB-IR.png" alt="LLVM IR VS. LLB" /></p>

<p><a href="https://github.com/moby/buildkit/blob/ebd98bcbe600c662a72ce9725417540f277be4d6/solver/pb/ops.proto">LLB</a> is defined as a protocol buffer, and this means that BuildKit frontends can make GRPC requests against buildkitd to build a container directly.</p>

<p><img src="bk-internals-images/Send-LLB.png" alt="LLVM IR VS. LLB" /></p>

<h2 id="programmatically-making-an-image">Programmatically Making An Image</h2>
<p>Alright, enough background.  Let’s programmatically generate the LLB for an image and then build an image.</p>

<table>
  <thead>
    <tr>
      <th>ℹ️ Using Go</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>In this example, we will be using Go which lets us leverage existing BuildKit libraries, but it’s possible to accomplish this in any language with Protocol Buffer support.</td>
    </tr>
  </tbody>
</table>

<p>Import LLB defintions:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import (
	"github.com/moby/buildkit/client/llb"
)
</code></pre></div></div>

<p>Create LLB for an Alpine image:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func createLLBState() llb.State {
	return llb.Image("docker.io/library/alpine").
		File(llb.Copy(llb.Local("context"), "README.md", "README.md")).
		Run(llb.Args([]string{"/bin/sh", "-c", "echo \"programmatically built\" &gt; /built.txt"})).
    Root()
}

</code></pre></div></div>
<p>We are accomplishing the equivalent of a <code class="language-plaintext highlighter-rouge">FROM</code> by using <code class="language-plaintext highlighter-rouge">llb.Image</code>. Then, we copy a file from the local file system into the image using <code class="language-plaintext highlighter-rouge">File</code> and <code class="language-plaintext highlighter-rouge">Copy</code>.  Finally, we <code class="language-plaintext highlighter-rouge">RUN</code> a command to echo some text to a file.  LLB has many more operations, but you can recreate many standard images with these three building blocks.</p>

<p>The final thing we need to do is turn this into protocol-buffer and emit it to standard out:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func main() {

	dt, err := createLLBState().Marshal(context.TODO(), llb.LinuxAmd64)
	if err != nil {
		panic(err)
	}
	llb.WriteTo(dt, os.Stdout)
}
</code></pre></div></div>
<p>Let’s look at the what this generates using the <code class="language-plaintext highlighter-rouge">dump-llb</code> option of buildctl:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> go run ./writellb/writellb.go | \
 buildctl debug dump-llb | \
 jq .

</code></pre></div></div>
<p>We get this JSON formatted LLB:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "Op": {
    "Op": {
      "source": {
        "identifier": "local://context",
        "attrs": {
          "local.unique": "s43w96rwjsm9tf1zlxvn6nezg"
        }
      }
    },
    "constraints": {}
  },
  "Digest": "sha256:c3ca71edeaa161bafed7f3dbdeeab9a5ab34587f569fd71c0a89b4d1e40d77f6",
  "OpMetadata": {
    "caps": {
      "source.local": true,
      "source.local.unique": true
    }
  }
}
{
  "Op": {
    "Op": {
      "source": {
        "identifier": "docker-image://docker.io/library/alpine:latest"
      }
    },
    "platform": {
      "Architecture": "amd64",
      "OS": "linux"
    },
    "constraints": {}
  },
  "Digest": "sha256:665ba8b2cdc0cb0200e2a42a6b3c0f8f684089f4cd1b81494fbb9805879120f7",
  "OpMetadata": {
    "caps": {
      "source.image": true
    }
  }
}
{
  "Op": {
    "inputs": [
      {
        "digest": "sha256:665ba8b2cdc0cb0200e2a42a6b3c0f8f684089f4cd1b81494fbb9805879120f7",
        "index": 0
      },
      {
        "digest": "sha256:c3ca71edeaa161bafed7f3dbdeeab9a5ab34587f569fd71c0a89b4d1e40d77f6",
        "index": 0
      }
    ],
    "Op": {
      "file": {
        "actions": [
          {
            "input": 0,
            "secondaryInput": 1,
            "output": 0,
            "Action": {
              "copy": {
                "src": "/README.md",
                "dest": "/README.md",
                "mode": -1,
                "timestamp": -1
              }
            }
          }
        ]
      }
    },
    "platform": {
      "Architecture": "amd64",
      "OS": "linux"
    },
    "constraints": {}
  },
  "Digest": "sha256:ba425dda86f06cf10ee66d85beda9d500adcce2336b047e072c1f0d403334cf6",
  "OpMetadata": {
    "caps": {
      "file.base": true
    }
  }
}
{
  "Op": {
    "inputs": [
      {
        "digest": "sha256:ba425dda86f06cf10ee66d85beda9d500adcce2336b047e072c1f0d403334cf6",
        "index": 0
      }
    ],
    "Op": {
      "exec": {
        "meta": {
          "args": [
            "/bin/sh",
            "-c",
            "echo \"programmatically built\" &gt; /built.txt"
          ],
          "cwd": "/"
        },
        "mounts": [
          {
            "input": 0,
            "dest": "/",
            "output": 0
          }
        ]
      }
    },
    "platform": {
      "Architecture": "amd64",
      "OS": "linux"
    },
    "constraints": {}
  },
  "Digest": "sha256:d2d18486652288fdb3516460bd6d1c2a90103d93d507a9b63ddd4a846a0fca2b",
  "OpMetadata": {
    "caps": {
      "exec.meta.base": true,
      "exec.mount.bind": true
    }
  }
}
{
  "Op": {
    "inputs": [
      {
        "digest": "sha256:d2d18486652288fdb3516460bd6d1c2a90103d93d507a9b63ddd4a846a0fca2b",
        "index": 0
      }
    ],
    "Op": null
  },
  "Digest": "sha256:fda9d405d3c557e2bd79413628a435da0000e75b9305e52789dd71001a91c704",
  "OpMetadata": {
    "caps": {
      "constraints": true,
      "platform": true
    }
  }
}
</code></pre></div></div>

<p>Looking through the output, we can see how our code maps to LLB.</p>

<p>Here is our <code class="language-plaintext highlighter-rouge">Copy</code> as part of a FileOp:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "Action": {
              "copy": {
                "src": "/README.md",
                "dest": "/README.md",
                "mode": -1,
                "timestamp": -1
              }
</code></pre></div></div>
<p>Here is mapping our build context for use in our <code class="language-plaintext highlighter-rouge">COPY</code> command:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  "Op": {
      "source": {
        "identifier": "local://context",
        "attrs": {
          "local.unique": "s43w96rwjsm9tf1zlxvn6nezg"
        }
      }
</code></pre></div></div>
<p>Similarly, the output contains LLB that corresponds to our  <code class="language-plaintext highlighter-rouge">RUN</code> and <code class="language-plaintext highlighter-rouge">FROM</code> commands.</p>

<h3 id="building-our-llb">Building Our LLB</h3>

<p>To build our image, we must first start <code class="language-plaintext highlighter-rouge">buildkitd</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run --rm --privileged -d --name buildkit moby/buildkit
export BUILDKIT_HOST=docker-container://buildkit
</code></pre></div></div>
<p>We can then build our image like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go run ./writellb/writellb.go | \
buildctl build \
--local context=. \
--output type=image,name=docker.io/agbell/test,push=true
</code></pre></div></div>
<p>The output flag lets us specify what backend we want BuildKit to use.  We will ask it to build an OCI image and push it to docker.io.</p>

<table>
  <thead>
    <tr>
      <th>ℹ️ Real-World Usage</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>In the real-world tool, we might want to programmatically make sure <code class="language-plaintext highlighter-rouge">buildkitd</code> is running and send the RPC request directly to it, as well as provide friendly error messages. For tutorial purposes, we will skip all that.</td>
    </tr>
  </tbody>
</table>

<p>We can run it like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker run -it --pull always agbell/test:latest /bin/sh

</code></pre></div></div>
<p>And we can then see the results of our programmatic <code class="language-plaintext highlighter-rouge">COPY</code> and <code class="language-plaintext highlighter-rouge">RUN</code> commands:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/ # cat built.txt 
programmatically built
/ # ls README.md
README.md
</code></pre></div></div>

<p>There we go! The <a href="https://github.com/agbell/compiling-containers/blob/main/writellb/writellb.go">full code example</a> can be a great starting place for your own programmatic docker image building.</p>

<h2 id="a-true-frontend-for-buildkit">A True Frontend for BuildKit</h2>

<p>A true compiler front end does more than just emit hardcoded IR.  A proper frontend takes in files, tokenizes them, parses them, generates a syntax tree, and then lowers that syntax tree into the internal representation.  <a href="https://matt-rickard.com/building-a-new-dockerfile-frontend/">Mockerfiles</a> are an example of such a frontend:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#syntax=r2d4/mocker
apiVersion: v1alpha1
images:
- name: demo
  from: ubuntu:16.04
  package:
    install:
    - curl
    - git
    - gcc
</code></pre></div></div>

<p>And because Docker build supports the <code class="language-plaintext highlighter-rouge">#syntax</code> command we can even build a Mockerfiles directly with <code class="language-plaintext highlighter-rouge">docker build</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build -f mockerfile.yaml
</code></pre></div></div>

<p>To support the #syntax command, all that is needed is to put the frontend in a docker image that accepts a GRPC request in the correct format, publish that image somewhere.  At that point, anyone can use your frontend <code class="language-plaintext highlighter-rouge">docker build</code> by just using <code class="language-plaintext highlighter-rouge">#syntax=yourimagename</code>.</p>

<h2 id="building-our-own-example-frontend-for-docker-build">Building Our Own Example Frontend for <code class="language-plaintext highlighter-rouge">Docker build</code></h2>

<p>Building a tokenizer and a parser as a GRPC service is beyond the scope of this article. But we can get our feet wet by extracting and modifying an existing frontend. The standard <a href="https://github.com/moby/buildkit/tree/master/frontend/dockerfile">dockerfile frontend</a> is easy to disentangle from the moby project.  I’ve pulled the relevant parts out into a <a href="https://github.com/agbell/compiling-containers/tree/main/ickfile">stand-alone repo</a>.  Let’s make some trivial modifications to it and test it out.</p>

<p>So far, we’ve only used the docker commands <code class="language-plaintext highlighter-rouge">FROM</code>, <code class="language-plaintext highlighter-rouge">RUN</code> and <code class="language-plaintext highlighter-rouge">COPY</code>.  At a surface level, with its capitalized commands, Dockerfile syntax looks a lot like the programming language <a href="https://blog.earthly.dev/intercal-yaml-and-other-horrible-programming-languages/">INTERCAL</a>. Let change these commands to their INTERCAL equivalent and develop our own Ickfile format <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote">2</a></sup>.</p>

<table>
  <thead>
    <tr>
      <th>Dockerfile</th>
      <th style="text-align: center">Ickfile</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>FROM</td>
      <td style="text-align: center">COME FROM</td>
    </tr>
    <tr>
      <td>RUN</td>
      <td style="text-align: center">PLEASE</td>
    </tr>
    <tr>
      <td>COPY</td>
      <td style="text-align: center">STASH</td>
    </tr>
  </tbody>
</table>

<p>The modules in the dockerfile frontend split the parsing of the input file into several discreet steps, with execution flowing this way:</p>

<p><img src="./bk-internals-images/controlflow.png" alt="ControlFlow from main.go to Dockerfile2LLB to Parser to Command.go" /></p>

<p>For this tutorial, we are only going to make trivial changes to the frontend.  We will leave all the stages intact and focus on customizing the existing commands to our tastes.  To do this, all we need to do is change <code class="language-plaintext highlighter-rouge">command.go</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package command

// Define constants for the command strings
const (
	Copy        = "stash"
	Run         = "please"
	From        = "come_from"
	...
)
</code></pre></div></div>

<p>Then we build our image:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build . -t agbell/ick
</code></pre></div></div>

<p>And we can use this image as a BuildKit frontend and build images with it like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#syntax=agbell/ick
COME_FROM alpine
STASH README.md README.md
PLEASE echo "custom frontend built" &gt; /built.txt"

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DOCKER_BUILDKIT=1 docker build . -f ./Ickfile -t ick 
</code></pre></div></div>

<p>And we can run it just like any other image:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker run -it ick /bin/sh
</code></pre></div></div>
<p>And we can then see results of our <code class="language-plaintext highlighter-rouge">STASH</code> and <code class="language-plaintext highlighter-rouge">PLEASE</code> commands:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/ # cat built.txt 
custom frontend built
/ # ls README.md
README.md
</code></pre></div></div>
<p>I’ve pushed this image to dockerhub.  Anyone can start building images using our <code class="language-plaintext highlighter-rouge">ickfile</code> format by adding <code class="language-plaintext highlighter-rouge">#syntax=agbell/ick</code> to an existing Dockerfile. No manual installation is required!</p>

<table>
  <thead>
    <tr>
      <th>ℹ️ Enabling BuildKit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>BuildKit is included but not enabled by default in the current version of Docker (<code class="language-plaintext highlighter-rouge">version 20.10.2</code>). To instruct <code class="language-plaintext highlighter-rouge">docker build</code> to use BuildKit set the following environment variable <code class="language-plaintext highlighter-rouge">DOCKER_BUILDKIT=1</code>. This will not be necessary once BuildKit reaches general availability.</td>
    </tr>
  </tbody>
</table>

<h2 id="conclusion">Conclusion</h2>
<p>We have learned that a three-phased structure borrowed from compilers powers building images, that an intermediate representation called LLB is the key to that structure.  Empowered by the knowledge, we have produced two frontends for building images.</p>

<p>This deep dive on frontends still leaves much to explore.  If you want to learn more, I suggest looking into BuildKit workers.  Workers do the actual building and are the secret behind <code class="language-plaintext highlighter-rouge">docker buildx</code>, and <a href="https://docs.docker.com/buildx/working-with-buildx/">multi-archtecture builds</a>. <code class="language-plaintext highlighter-rouge">docker build</code> also has support for remote workers and cache mounts, both of which can lead to faster builds.</p>

<p><a href="http://earthly.dev/">Earthly</a> uses BuildKit internally for its repeatable build syntax. Without it, our containerized Makefile-like syntax would not be possible. If you want a saner CI process, then <a href="http://earthly.dev/">you should check it out</a>.</p>

<p>There is also much more to explore about how modern compilers work. Modern compilers often have many stages and more than one intermediate representation, and they are often able to do very sophisticated optimizations.<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote">3</a></sup></p>

<p>The difference between the two is murky, but I like to think of a transpiler as something that translates from one human-readable text-based programming language to another. The java compiler translates Java code to java byte code, which is a binary format.  Meanwhile, PureScript, which translates to JavaScript, is regarded as a transpiler because JavaScript is text-based.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Fun Fact: You may have heard the term transpiler or transcompiler in the past. Transpilers are compilers that transform one programming language into another. If all compilers translate from one language to another, then what makes something a transpiler? <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Ick is the name of the INTERCAL compiler. Therefore Ickfile can be its Dockerfile equivalent. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>If you want to learn more about optimizing compilers, Matt Godbolt’s article on <a href="https://queue.acm.org/detail.cfm?id=3372264">C++ Optimizations</a> is a great place to start. The book <a href="https://www.amazon.com/Building-Optimizing-Compiler-Bob-Morgan/dp/155558179X">Building an Optimizing Compiler</a> is also often recommended online. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET